# Наследование

Часто оказывается, что все объекты одного класса **являются** также и объектами некоторого другого класса.
В таком случае первый класс оказывается **подклассом** второго.

Так, например, все *натуральные числа* **являются** также и *действительными*, хотя обратное неверно.
Все *вектора* можно рассматривать как *матрицы* из одного столбца.
Все *преподаватели* университета **являются** его *сотрудниками*.

Программный код, который предназначен для управления расписанием занятий в университете,
оперирует объектами классов *преподаватель*, *группа*, *аудитория*.
При этом, для программы, которая управляет бухгалтерией университета, часто не будет иметь значения, 
кем является *сотрудник*: *преподавателем*, *администратором*, *охранником* или *библиотекарем*.
Важно, чтобы у сотрудника был записан номер договора, зарплатного счёта и трудовой книжки.
В пропускной же системе и это не важно, она должна уметь одинаково обрабатывать и *сотрудников* и *студентов* и *гостей* университета.

## Полиморфизм
Таким образом, возникает необходимость иметь в зыке программирования возможности для 
*одинаковой обработки данных разных типов*.
Такие возможности называются *полиморфизмом*.

В основе типовой системы языка C лежат числа различной точности.
Можно заметить, что многие кодовые конструкции языка C могут быть использованы как для одних числовых типов, так и для других:
в любое выражение на место `double` значения можно подставить `int` и т.д. (см. также *ad hoc*-полиморфизм).

Но возможности для задания сложных пользовательских типов, появившиеся в C++ требуют и новых средств реализации полиморфизма.

## Отношение наследования
Если все объекты класса `X` также должны **являться** и объектами класса `Y`, 
можно объявить класс `X` **наследником** класса `Y`.
```c++
class X {};
class Y : public X {};
```
В таком случае класс `X` называется базовым классом (супер-классом, классом-предком),
а класс `Y` -- производным классом (под-классом, классом-потомком).

Класс потомок наследует все поля и методы своего базового класса.
```c++
class Person {
public:
    std::string name;
    int age;
};

class Student : public Person {
public:
    int groupId;
};

Student s;
s.name = "Alexey";
s.age = 42;
s.groupId = 14122;
```

### Области видимости
Наследникам не видны `private` члены базового класса.
Спецификатор `protected` позволяет задавать члены, видимые всем наследникам, но невидимые извне.

### Конструкторы
Перед выполнением конструктора класса-наследника, выполняется вызов конструкторов всех его базовых классов.
Конструктор базового класса можно вызвать явно, указав его в списке инициализации.
```c++
class Person {
public:
    Person(std::string const & name, int age) : name(name), age(age) {}
};

class Student : public Person {
public:
    Student(std::string const & name, int age, int groupId) : Person(name, age), groupId(groupId) {}
};
```

## Полиморфизм подтипов
В языке C++ указатель на объект класса-наследника может быть использован везде, где может быть использован указатель на объект базового класса.
Указатель на наследника можно присваивать в указатель на базовый класс.
```c++
void print(Person * p) {
    std::cout << p->name << " " << p->age << std::endl;
}

Student s("Ivan", 23, 4237);
print(&s);
```

### Переопределение методов
Класс-наследник может предоставлять свою собственную реализацию для методов базового класса.
```c++
class Person {
public:
    void print() {
        std::cout << name << std::endl;
        std::cout << age << std::endl;
    }
};

class Student : public Person {
public:
    void print() {
        Person::print();
        std::cout << groupId << std::endl;
    }
};
```
"Однако" в начале предложения не обособляется запятой.


