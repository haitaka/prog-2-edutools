# Наследование

Часто оказывается, что все объекты одного класса **являются** также и объектами некоторого другого класса.
В таком случае первый класс оказывается **подклассом** второго.

Так, например, все *натуральные числа* **являются** также и *действительными*, хотя обратное неверно.
Все *вектора* можно рассматривать как *матрицы* из одного столбца.
Все *преподаватели* университета **являются** его *сотрудниками*.

Программный код, который предназначен для управления расписанием занятий в университете,
оперирует объектами классов *преподаватель*, *группа*, *аудитория*.
При этом, для программы, которая управляет бухгалтерией университета, часто не будет иметь значения, 
кем является *сотрудник*: *преподавателем*, *администратором*, *охранником* или *библиотекарем*.
Важно, чтобы у сотрудника был записан номер договора, зарплатного счёта и трудовой книжки.
В пропускной же системе и это не важно, она должна уметь одинаково обрабатывать и *сотрудников* и *студентов* и *гостей* университета.

## Полиморфизм
Таким образом, возникает необходимость иметь в зыке программирования возможности для 
*одинаковой обработки данных разных типов*.
Такие возможности называются *полиморфизмом*.

В основе типовой системы языка C лежат числа различной точности.
Можно заметить, что многие кодовые конструкции языка C могут быть использованы как для одних числовых типов, так и для других:
в любое выражение на место `double` значения можно подставить `int` и т.д. (см. также *ad hoc*-полиморфизм).

Но возможности для задания сложных пользовательских типов, появившиеся в C++ требуют и новых средств реализации полиморфизма.

## Отношение наследования
Если все объекты класса `X` также должны **являться** и объектами класса `Y`, 
можно объявить класс `X` **наследником** класса `Y`.
```c++
class X {};
class Y : public X {};
```
В таком случае класс `X` называется базовым классом (супер-классом, классом-предком),
а класс `Y` -- производным классом (под-классом, классом-потомком).

Класс потомок наследует все поля и методы своего базового класса.
```c++
class Person {
public:
    std::string name;
    int age;
};

class Student : public Person {
public:
    int groupId;
};

Student s;
s.name = "Alexey";
s.age = 42;
s.groupId = 14122;
```

### Области видимости
Наследникам не видны `private` члены базового класса.
Спецификатор `protected` позволяет задавать члены, видимые всем наследникам, но невидимые извне.

### Конструкторы
Перед выполнением конструктора класса-наследника, выполняется вызов конструкторов всех его базовых классов.
Конструктор базового класса можно вызвать явно, указав его в списке инициализации.
```c++
class Person {
public:
    Person(std::string const & name, int age) : name(name), age(age) {}
};

class Student : public Person {
public:
    Student(std::string const & name, int age, int groupId) : Person(name, age), groupId(groupId) {}
};
```

## Полиморфизм подтипов
В языке C++ указатель на объект класса-наследника может быть использован везде, где может быть использован указатель на объект базового класса.
Указатель на наследника можно присваивать в указатель на базовый класс.
```c++
void print(Person * p) {
    std::cout << p->name << " " << p->age << std::endl;
}

Student s("Ivan", 23, 4237);
print(&s);
```
То же верно и для ссылок.

Таким образом, любой код, который может работать со ссылками на объекты базового класса, может работать и с любыми производными классами.

### Переопределение методов
Класс-наследник может предоставлять свою собственную реализацию для методов базового класса.
```c++
class Person {
public:
    void print() {
        std::cout << name << std::endl;
        std::cout << age << std::endl;
    }
};

class Student : public Person {
public:
    void print() {
        Person::print();
        std::cout << groupId << std::endl;
    }
};
```
В таком случае выбор метода при вызове производится на основе *формального* типа *приёмника* (аргумента `this`).
```c++
Person * p1 = new Person("Ivan", 23);
Person * p2 = new Student("Ivor", 42, 20129);
p1->print(); // Ivan 23
p2->print(); // Ivor 42
```
Несмотря на то, что переменная `p2` указывает на объект класса `Student`, номер группы для неё не распечатается.
Так как *формальный* тип переменной `p2` -- `Person`.

### Виртуальные методы
Ключевое слово `virtual` в объявлении метода означает, что выбор переопределяемого метода необходимо производить на основе
*фактического* типа объекта в памяти, а не на основе *формального* типа переменной.
```c++
class Person {
public:
    virtual void print() {
        std::cout << name << std::endl;
        std::cout << age << std::endl;
    }
};

class Student : public Person {
public:
    virtual void print() override {
        Person::print();
        std::cout << groupId << std::endl;
    }
};

Person * p1 = new Person("Ivan", 23);
Person * p2 = new Student("Ivor", 42, 20129);
p1->print(); // Ivan 23
p2->print(); // Ivor 42 20129
```
Однако обратите внимание, что *виртуальный вызов* работает только для ссылок и указателей.

При присваивании *объекта* наследника в переменную типа *объект* базового класса произойдёт копирование с "расслоением",
и часть объекта, относящаяся к классу-наследнику будет потеряна.
Чтобы избежать подобных проблем, рекомендуется удалять (`= delete`) конструкторы копирования в полиморфных классах.

### Чисто виртуальные методы
В некоторых случаях базовый класс используется для представления некой *абстрактной* концепции, 
а реальными объектами могут быть только представители классов-наследников.
Тогда базовый класс может лишь объявлять наличие в себе некоторого метода, но не предоставлять его реализацию вообще.
```c++
class Figure {
public:
    virtual double area() = 0;
};

class Square : public Figure {
public:
    virtual double area() override {
        return side * side;
    }
private:
    double side;
};
```
Такие функции называются *чисто виртуальными*, вместо их тела пишется `= 0`
Класс, содержащий хотя бы одну чисто виртуальную функцию, называется *абстрактным*.
Объекты *абстрактных* классов создавать запрещено.
```c++
Figure f; // compile error
Figure * fp = new Figure(); // compile error
```
